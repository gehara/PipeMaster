#' Simulate Segregating Sites using scrm
#' @description This function simulates segregating sites using the scrm coalescent simulator.
#'              It outputs a fixed-size 2D matrix (nsam x n.sites) per replicate, suitable for
#'              machine-learning / CNN-based demographic inference. For each locus, scrm returns a
#'              0/1 seg_sites matrix which is sorted by mutation frequency, padded/truncated to n.sites,
#'              then summed across loci into a single integer matrix.
#' @param model A model object built by the main.menu function.
#' @param use.alpha Logical. If TRUE the most recent population size change will be exponential. If FALSE sudden demographic changes. Default is FALSE.
#' @param nsim.blocks Number of blocks to simulate. The total number of simulations is: nsim.blocks x block.size (x ncores when ncores > 1).
#' @param block.size Simulations are performed in blocks. This argument defines the size of the block in number of simulations, i.e. how many simulations to run per block.
#'                   A block of 1000 will work for most cases. Increase the total number of simulations with nsim.blocks argument.
#' @param n.sites Integer. Number of segregating site columns in the output matrix. Sites are sorted by frequency and padded/truncated to this size. Default is 100.
#' @param path Path to write the output. By default outputs will be saved in the working directory.
#' @param output.name String. The prefix of the output names. Default is "model".
#' @param append.sims Logical. If TRUE simulations will be appended in the last output. Default is FALSE.
#' @param mu.rates List. Distribution to sample the mutation rates. The first element of the list should be the name of the distribution as a character string.
#'                 The second element of the list must be the number of loci. The following elements are the parameters of the distribution.
#'                 Ex.: mu.rates = list("rtnorm", 1000, 1e-9, 1e-9, 0). If NULL, rates are sampled from the model priors. Default is NULL.
#' @param ncores Number of cores for parallel execution. When ncores > 1, separate R worker processes are spawned. Default is 1.
#' @return Writes two files: SEGSITES_{output.name}.txt (one flattened row per replicate, nsam*n.sites columns, no header) and PARAMS_{output.name}.txt (header row followed by one row per replicate with parameter values including mean.rate and sd.rate).
#' @examples
#' \dontrun{
#' # Load example demographic models
#' data("A_piscivorus", package = "PipeMaster")
#'
#' # Optimize model for uniform sample sizes
#' Is_opt <- optimize.sfs.model(Is)
#' nsam <- sum(as.numeric(Is_opt$I[1, 4:ncol(Is_opt$I)]))
#'
#' # Quick test run (small block size, single core)
#' tmpdir <- tempdir()
#' sim.stacked.segsites(model = Is_opt,
#'                      nsim.blocks = 1,
#'                      block.size = 10,
#'                      n.sites = 50,
#'                      path = tmpdir,
#'                      use.alpha = FALSE,
#'                      output.name = "test_segsites",
#'                      ncores = 1)
#'
#' # Read results
#' ss <- read.table(file.path(tmpdir, "SEGSITES_test_segsites.txt"))
#' params <- read.table(file.path(tmpdir, "PARAMS_test_segsites.txt"), header = TRUE)
#'
#' # Each replicate is one row (flattened nsam x n.sites matrix)
#' nrow(ss)     # 10 replicates
#' ncol(ss)     # nsam * n.sites
#'
#' # Reshape one replicate back to matrix
#' mat <- matrix(as.numeric(ss[1, ]), nrow = nsam, ncol = 50, byrow = TRUE)
#' }
#' @author Marcelo Gehara
#' @export
sim.stacked.segsites <- function(model, use.alpha=FALSE, nsim.blocks=5, block.size=1000,
                               n.sites=100, path=getwd(), output.name="model",
                               append.sims=FALSE, mu.rates=NULL, ncores=1) {

  WD <- getwd()

  if(class(model) != "Model") {
    stop("First argument should be an object of class Model generated by the main.menu() function.")
  }

  # Validate uniform per-population sample sizes across all loci
  npop <- as.numeric(model$I[1, 3])
  pop_cols <- 4:(3 + npop)
  pop_sizes <- matrix(as.numeric(model$I[, pop_cols]), ncol = npop)
  if(nrow(unique(pop_sizes)) > 1) {
    stop("All loci must have uniform per-population sample sizes for segsites simulation.\n",
         "  Use optimize.sfs.model() to downsample your model to uniform sample sizes first.")
  }

  setwd(path)
  on.exit(setwd(WD))

  ############### Header: write parameter names
  if(append.sims == FALSE) {
    com <- PipeMaster:::ms.commander2(model, use.alpha = use.alpha)

    # parameter names: keep non-rate params, replace per-locus rates with mean.rate + sd.rate
    par.names <- com[[nrow(model$loci) + 1]][1, ]
    par.names <- par.names[-length(par.names)]  # drop scalar
    rate.idx <- which(par.names %in% model$loci[,1])
    if(length(rate.idx) > 0) {
      par.names <- c(par.names[-rate.idx], "mean.rate", "sd.rate")
    }

    write.table(t(par.names), file = paste0("PARAMS_", output.name, ".txt"),
                quote = FALSE, row.names = FALSE, col.names = FALSE,
                append = FALSE, sep = "\t")
    # No header for SEGSITES file
  }

  ############### Multi-core path
  if(ncores > 1) {
    abs.path <- normalizePath(getwd())
    save(model, nsim.blocks, block.size, use.alpha, output.name, n.sites, mu.rates,
         file = file.path(abs.path, ".PM_worker_params.RData"))

    worker_script <- paste(
      'args <- commandArgs(TRUE)',
      'worker_id <- as.integer(args[1])',
      'suppressMessages(library(PipeMaster))',
      sprintf('base_path <- "%s"', abs.path),
      'load(file.path(base_path, ".PM_worker_params.RData"))',
      'worker_dir <- file.path(base_path, paste0(".worker_", worker_id))',
      'dir.create(worker_dir, showWarnings=FALSE)',
      'sim.stacked.segsites(model=model, nsim.blocks=nsim.blocks, block.size=block.size,',
      '             path=worker_dir, use.alpha=use.alpha, n.sites=n.sites,',
      '             append.sims=TRUE, mu.rates=mu.rates,',
      '             output.name=output.name, ncores=1)',
      'write("done", file.path(base_path, paste0(".worker_", worker_id, ".done")))',
      'quit(save="no")',
      sep = "\n")
    writeLines(worker_script, file.path(abs.path, ".PM_worker.R"))

    start.time <- Sys.time()
    for(w in 1:ncores) {
      system(paste("Rscript", file.path(abs.path, ".PM_worker.R"), w,
                   ">", file.path(abs.path, paste0(".worker_", w, ".log")), "2>&1"),
             wait = FALSE)
    }
    cat(paste("PipeMaster:: Launched", ncores, "worker processes"), "\n")

    total_expected <- nsim.blocks * block.size * ncores
    while(TRUE) {
      Sys.sleep(5)
      done_count <- sum(file.exists(file.path(abs.path, paste0(".worker_", 1:ncores, ".done"))))

      total_sims <- 0
      for(w in 1:ncores) {
        wf <- file.path(abs.path, paste0(".worker_", w), paste0("SEGSITES_", output.name, ".txt"))
        if(file.exists(wf)) {
          n <- length(readLines(wf))
          nsam <- sum(as.numeric(model$I[1, 4:ncol(model$I)]))
          if(n > 0) total_sims <- total_sims + floor(n / nsam)
        }
      }

      elapsed_h <- as.numeric(difftime(Sys.time(), start.time, units = "hours"))
      if(total_sims > 0 && elapsed_h > 0) {
        rate <- total_sims / elapsed_h
        remaining <- round(max(0, (total_expected - total_sims) / rate), 3)
        cat(paste0("PipeMaster:: ", total_sims, " of ", total_expected,
                   " (~", round(rate), " sims/h) | ~", remaining,
                   " hours remaining | ", done_count, "/", ncores, " workers done"), "\n")
      }
      if(done_count >= ncores) break
    }

    cat("Compiling results from workers", sep = "\n")

    # Compile SEGSITES files
    outfile_ss <- file.path(abs.path, paste0("SEGSITES_", output.name, ".txt"))
    for(w in 1:ncores) {
      wf <- file.path(abs.path, paste0(".worker_", w), paste0("SEGSITES_", output.name, ".txt"))
      if(file.exists(wf)) {
        worker_data <- readLines(wf)
        if(length(worker_data) > 0) {
          cat(paste(worker_data, collapse = "\n"), "\n", file = outfile_ss, append = TRUE, sep = "")
        }
      }
    }

    # Compile PARAMS files
    outfile_par <- file.path(abs.path, paste0("PARAMS_", output.name, ".txt"))
    for(w in 1:ncores) {
      wf <- file.path(abs.path, paste0(".worker_", w), paste0("PARAMS_", output.name, ".txt"))
      if(file.exists(wf)) {
        worker_data <- readLines(wf)
        if(length(worker_data) > 0) {
          cat(paste(worker_data, collapse = "\n"), "\n", file = outfile_par, append = TRUE, sep = "")
        }
      }
    }

    # Clean up worker files
    for(w in 1:ncores) {
      unlink(file.path(abs.path, paste0(".worker_", w)), recursive = TRUE)
      f <- file.path(abs.path, paste0(".worker_", w, ".done"))
      if(file.exists(f)) file.remove(f)
    }
    file.remove(file.path(abs.path, ".PM_worker_params.RData"))
    file.remove(file.path(abs.path, ".PM_worker.R"))
    for(w in 1:ncores) {
      f <- file.path(abs.path, paste0(".worker_", w, ".log"))
      if(file.exists(f)) file.remove(f)
    }

    end.time <- Sys.time()
    elapsed_h <- as.numeric(difftime(end.time, start.time, units = "hours"))
    cat(paste0("PipeMaster:: Done! ", total_expected, " simulations in ",
               round(elapsed_h, 3), " hours (~", round(total_expected / elapsed_h), " sims/h)"), "\n")

  } else {
    ############### Single-core path
    sim.segsites.func <- function() {
      for(i in 1:block.size) {
        com <- PipeMaster:::ms.commander2(model, use.alpha = use.alpha)

        nsam <- sum(as.numeric(model$I[1, 4:ncol(model$I)]))
        n_loci <- nrow(model$loci)

        # override mutation rates if mu.rates is provided
        if(!is.null(mu.rates)) {
          user.rates <- do.call(mu.rates[[1]], args = mu.rates[2:length(mu.rates)])
          if(length(user.rates) < n_loci) user.rates <- rep_len(user.rates, n_loci)
          par.all <- com[[n_loci + 1]]
          ms.scalar <- as.numeric(par.all[2, ncol(par.all)])
          for(u in 1:n_loci) {
            bp <- as.numeric(model$loci[u, 2])
            new.theta <- ms.scalar * user.rates[u] * bp
            com[[u]] <- sub("-t\\s+[0-9.eE+\\-]+", paste("-t", new.theta), com[[u]])
          }
          rate.rows <- which(par.all[1, ] %in% model$loci[,1])
          for(r in seq_along(rate.rows)) {
            par.all[2, rate.rows[r]] <- as.character(user.rates[r])
          }
          com[[n_loci + 1]] <- par.all
        }

        # Build 3D array: nsam x n.sites x n_loci
        arr <- array(0L, dim = c(nsam, n.sites, n_loci))
        for(u in 1:n_loci) {
          scrm.out <- scrm::scrm(paste(nsam, 1, com[[u]]))
          seg <- scrm.out$seg_sites[[1]]
          if(ncol(seg) > 0) {
            arr[,,u] <- process_segsites(seg, n.sites)
          }
        }

        # Sum across loci -> nsam x n.sites matrix
        result <- apply(arr, c(1, 2), sum)

        # Re-sort columns by colSums descending
        result <- result[, order(colSums(result), decreasing = TRUE), drop = FALSE]

        # Extract parameters (drop scalar, summarize per-locus rates)
        par <- com[[n_loci + 1]][2, ]
        par <- par[-length(par)]  # drop scalar
        par.names.tmp <- com[[n_loci + 1]][1, ]
        par.names.tmp <- par.names.tmp[-length(par.names.tmp)]
        rate.idx <- which(par.names.tmp %in% model$loci[,1])
        if(length(rate.idx) > 0) {
          rates <- as.numeric(par[rate.idx])
          par <- c(par[-rate.idx], mean(rates), sd(rates))
        }

        # Flatten matrix to single row (row-major) and write to SEGSITES file
        result_row <- as.vector(t(result))
        write.table(t(result_row), file = paste0("SEGSITES_", output.name, ".txt"),
                    quote = FALSE, row.names = FALSE, col.names = FALSE,
                    append = TRUE, sep = "\t")

        # Write parameter row to PARAMS file
        write.table(t(par), file = paste0("PARAMS_", output.name, ".txt"),
                    quote = FALSE, row.names = FALSE, col.names = FALSE,
                    append = TRUE, sep = "\t")
      }
    }

    total.sims <- 0
    for(k in 1:nsim.blocks) {
      start.time <- Sys.time()
      sim.segsites.func()

      end.time <- Sys.time()
      total.sims <- total.sims + block.size
      cycle.time <- (as.numeric(end.time) - as.numeric(start.time)) / 60 / 60
      total.time <- cycle.time * nsim.blocks
      passed.time <- cycle.time * k
      remaining.time <- round(total.time - passed.time, 3)
      cat(paste("PipeMaster:: ", total.sims, " (~", round(block.size / cycle.time),
                " sims/h) | ~", remaining.time, " hours remaining", sep = ""), "\n")
    }
    print("Done!")
  }
}


# Internal helper: process a single locus seg_sites matrix to fixed n.sites columns
# Sorts columns by frequency (colSums) descending, pads with zeros or truncates
process_segsites <- function(mat, n.sites) {
  if(ncol(mat) == 0) return(matrix(0L, nrow = nrow(mat), ncol = n.sites))
  ord <- order(colSums(mat), decreasing = TRUE)
  mat <- mat[, ord, drop = FALSE]
  nc <- ncol(mat)
  if(nc >= n.sites) {
    mat[, 1:n.sites, drop = FALSE]
  } else {
    cbind(mat, matrix(0L, nrow = nrow(mat), ncol = n.sites - nc))
  }
}
