#' Plot simulated data against observed
#' @description This function plots an histogram of the simulated summary statistics with the corresponding observed value as a red line for comparison.
#' @param sim A data frame with simulated data.
#' @param obs A vector of observed summary stats corresponding to the sim object.
#' @return Graphic
#' @author Marcelo Gehara
#' @export
plot.sim.obs <- function(sim, obs)
  {
    mylabels <- colnames(sim)
    for (i in 1:ncol(sim)) {
      hist(sim[, i], breaks = 20, xlab = mylabels[i], main = "",
           xlim = c(min(c(na.omit(sim[, i]),obs[i])), max(c(na.omit(sim[, i]),obs[i]))))
      abline(v = obs[i], col = 2)
    }
  }

#' Plot prior distribution
#' @description This function plots a density of the simulated prior.
#' @param model A model object.
#' @param nsamples Number of samples to draw from each prior distribution.
#' @param mu.rates List. Distribution to sample the mutation rates. If NULL, rates are sampled from the model. See sim.sumstat for details.
#' @return Graphic
#' @author Marcelo Gehara
#' @export
plot.priors <- function(model, nsamples=1000, mu.rates=NULL){

  param = NULL
  pb = txtProgressBar(min = 1, max = nsamples, initial = 1)
  for(j in 1:nsamples){
    param.samples <- as.numeric(PipeMaster:::msABC.commander(model, use.alpha=F, arg=1)[[2]][2,])
    if(!(is.null(mu.rates))){
      rates <- do.call(mu.rates[[1]],args=c(1,mu.rates[2:length(mu.rates)]))
      param <- rbind(param,c(param.samples, rates))
      } else {
      rates <- PipeMaster:::sample.mu.rates(model)[[2]]
      param <- rbind(param,c(param.samples, rates))
    }
    setTxtProgressBar(pb,j)
  }
  if(!(is.null(mu.rates))){
    colnames(param) <- c(PipeMaster:::msABC.commander(model, use.alpha=F, arg=1)[[2]][1,],"mu")
  } else {
    colnames(param) <- c(PipeMaster:::msABC.commander(model, use.alpha=F, arg=1)[[2]][1,],"mean.mu", "sd.mu")
  }

  par(mfrow=c(3,3))
  for(i in 1:ncol(param)){
    plot(density(param[,i]), main=colnames(param)[i], col=2)
  }
}

#' Get a table with prior distributions.
#' @description This function makes a table with the parameters of the model and respective prior distribution.
#' @param model A model object.
#' @return A data frame with 4 columns: parameter name, first parameter of prior distribution, second parameter of prior distribution, prior distribution.
#' @author Marcelo Gehara
#' @export
get.prior.table <- function(model){

  flags <- model$flags

  for(i in 1:length(flags)){
    if(is.null(nrow(flags[[i]]))){
      flags[[i]] <- do.call(rbind,flags[[i]])
    }
  }
    flags <- do.call(rbind,flags)
    flags <- as.data.frame(flags[,c(1,4,5,6)])
    colnames(flags) <- c("Parameter","prior.1","prior.2","distribution")
    return(flags)
}

#' Update priors using a prior table
#' @description This function updates the prior of your models using a prior table. see get.prior.table function
#' @param tab A prior table generated by the get.prior.table function.
#' @param model A model object.
#' @return A data frame with 4 columns: parameter name, first parameter of prior distribution, second parameter of prior distribution, prior distribution.
#' @author Marcelo Gehara
#' @export
update.priors<-function(tab, model){

  for(i in 1:nrow(tab)){

    x <- model$flags[[grep(tab[i,1], model$flags)]]

    if(is.null(nrow(x))){
      y <- which(mapply(grep,paste0("^",tab[i,1],"$"),x)==1)
      x <- x[y]
      x <- x[[1]]
      x[grep(tab[i,1], x),4:6] <- as.matrix(tab[i, 2:4])
      model$flags[[grep(tab[i,1], model$flags)]][[y]]<-x
    } else {
      x[grep(tab[i,1], x),4:6] <- as.matrix(tab[i, 2:4])
      model$flags[[grep(tab[i,1], model$flags)]] <- x
    }

  }
  return(model)
}

#' Plot a 2D Joint Site Frequency Spectrum
#' @description Plots a 2D joint SFS as a heatmap with log10 color scale and colorbar,
#'              following the standard convention used by dadi and moments.
#'              Accepts either a matrix or a flattened vector (as output by sim.sfs for 2-population models).
#'              Zero entries are masked (shown as white). Pop 1 is on the y-axis and Pop 2 on the x-axis.
#' @param sfs A matrix (joint SFS) or numeric vector (flattened joint SFS from sim.sfs output).
#' @param pop_sizes Integer vector of length 2 with per-population sample sizes. Required when sfs is a vector.
#' @param pop_names Character vector of length 2 with population labels. Default is c("Pop 1", "Pop 2").
#' @param folded Logical. If TRUE, folds the SFS by combining entries (i,j) with their complement (n1-i, n2-j). Default is FALSE.
#' @param log Logical. If TRUE (default), uses log10 color scale.
#' @param col Color palette vector. Default uses a 256-color YlOrRd palette.
#' @param main Plot title. Default is "Joint SFS".
#' @param ... Additional arguments passed to image().
#' @examples
#' \dontrun{
#' # From sim.sfs output
#' sim.data <- read.table("SIM_SFS_model.txt", header = TRUE)
#' sfs_cols <- grep("^sfs_", colnames(sim.data))
#'
#' # Plot a single replicate (unfolded)
#' sfs_vec <- as.numeric(sim.data[1, sfs_cols])
#' plot.2D.sfs(sfs_vec, pop_sizes = c(64, 14))
#'
#' # Plot folded SFS
#' plot.2D.sfs(sfs_vec, pop_sizes = c(64, 14), folded = TRUE)
#'
#' # Plot average across replicates
#' avg_sfs <- colMeans(sim.data[, sfs_cols])
#' plot.2D.sfs(avg_sfs, pop_sizes = c(64, 14),
#'             pop_names = c("A. piscivorus", "A. conanti"))
#' }
#' @author Marcelo Gehara
#' @rawNamespace export(plot.2D.sfs)
plot.2D.sfs <- function(sfs, pop_sizes = NULL,
                         pop_names = c("Pop 1", "Pop 2"),
                         folded = FALSE,
                         log = TRUE,
                         col = NULL,
                         main = "Joint SFS", ...) {

  if(is.null(dim(sfs))) {
    if(is.null(pop_sizes) || length(pop_sizes) != 2) {
      stop("pop_sizes (integer vector of length 2) required when sfs is a vector.")
    }
    sfs <- matrix(as.numeric(sfs), nrow = pop_sizes[1] + 1, ncol = pop_sizes[2] + 1)
  }

  n1 <- nrow(sfs) - 1
  n2 <- ncol(sfs) - 1

  # Fold the SFS if requested
  if(folded) {
    sfs <- fold_2d_sfs(sfs)
    if(main == "Joint SFS") main <- "Folded Joint SFS"
  }

  # Default color palette
  if(is.null(col)) col <- hcl.colors(256, "YlOrRd", rev = TRUE)
  ncolors <- length(col)

  # Mask zeros (NA -> white in plot)
  sfs[sfs == 0] <- NA

  # Log10 transform
  if(log) sfs <- log10(sfs)

  zlim <- range(sfs, na.rm = TRUE)

  # Save and restore graphics state
  old_par <- par(no.readonly = TRUE)
  on.exit(par(old_par))

  # Layout: main plot + colorbar
  layout(matrix(c(1, 2), nrow = 1), widths = c(5, 1.2))

  # --- Main heatmap ---
  # Transpose so pop1 = y-axis, pop2 = x-axis (dadi/moments convention)
  par(mar = c(4.5, 4.5, 3, 0.5))
  image(0:n2, 0:n1, t(sfs),
        zlim = zlim, col = col,
        xlab = paste(pop_names[2], "derived allele count"),
        ylab = paste(pop_names[1], "derived allele count"),
        main = main,
        useRaster = TRUE, axes = FALSE, ...)
  axis(1)
  axis(2)
  box()

  # --- Colorbar ---
  par(mar = c(4.5, 0.5, 3, 3.5))
  bar_vals <- seq(zlim[1], zlim[2], length.out = ncolors)
  image(1, bar_vals, matrix(bar_vals, nrow = 1), col = col,
        axes = FALSE, xlab = "", ylab = "")
  if(log) {
    at_vals <- pretty(bar_vals)
    labels <- sapply(at_vals, function(x) as.expression(bquote(10^.(round(x, 1)))))
    axis(4, at = at_vals, labels = labels, las = 1)
  } else {
    axis(4, las = 1)
  }
  box()
}

# Internal helper: fold a 2D joint SFS
# Combines each entry (i,j) with its complement (n1-i, n2-j).
# The summed value is placed at whichever entry has the smaller total
# derived allele count (i+j). Entries in the upper half become zero.
fold_2d_sfs <- function(sfs) {
  n1 <- nrow(sfs) - 1
  n2 <- ncol(sfs) - 1
  folded <- matrix(0, nrow = n1 + 1, ncol = n2 + 1)
  processed <- matrix(FALSE, nrow = n1 + 1, ncol = n2 + 1)

  for(i in 0:n1) {
    for(j in 0:n2) {
      if(processed[i + 1, j + 1]) next
      mi <- n1 - i
      mj <- n2 - j
      if(i == mi && j == mj) {
        # Self-complementary entry
        folded[i + 1, j + 1] <- sfs[i + 1, j + 1]
      } else {
        # Sum the pair, place at the entry with smaller i+j
        val <- sfs[i + 1, j + 1] + sfs[mi + 1, mj + 1]
        if(i + j <= mi + mj) {
          folded[i + 1, j + 1] <- val
        } else {
          folded[mi + 1, mj + 1] <- val
        }
      }
      processed[i + 1, j + 1] <- TRUE
      processed[mi + 1, mj + 1] <- TRUE
    }
  }

  return(folded)
}

#' Plot model
#' @description This function plots a graphical representation of your model.
#' @param model A model object generated in the main.menu.
#' @param use.alpha Logical. If TRUE the most recent population size change will be exponential. If FALSE sudden demographic changes. Default is FALSE.
#'                  This argument changes ONLY the MOST RECENT demographic change. You should indicate the population numbers for the exponential change
#'                  together with the logical argument in a vector. Ex.c(T,1,2)
#' @param average.of.priors logical. if TRUE parameters for the plot will be equal to the average of prior values.
#' @param xlab Character. Label for the x-axis. Default is "Population".
#' @param ylab Character. Label for the y-axis. Default is "Time before present (generations)".
#' @param axes logical. if TRUE plot axes with models. Default is TRUE.
#' @return Graphic
#' @author Marcelo Gehara. This function is a wrapper of the PlotMS function of the POPDemog package.
#' @export
PlotModel<-function(model, use.alpha=F, average.of.priors=F,
                    xlab = "Population",
                    ylab = "Time before present (generations)",
                    axes = T){

  model$loci <- t(data.frame(c("rate1" ,"1000", "1",  "1e-08", "1e-08", "runif")))

  model$I <- t(data.frame(c(model$I[1,1:3],rep(10,as.numeric(model$I[1,3])))))

  if(average.of.priors==T){
    x <- PipeMaster:::ms.commander.forplot(model, use.alpha = use.alpha)
    POPdemog::PlotMS(x[[1]], type="ms", col.pop = c(3:(as.numeric(model$I[1,3])+2)),
                     lwd.arrow = 2, size.scale = "log",log.base = 10, time.scale = "generation",
                     N4=4000000, axes = axes, xlab = xlab, ylab = ylab)
  } else { x <- PipeMaster:::ms.commander2(model, use.alpha = use.alpha)
            POPdemog::PlotMS(x[[1]], type="ms", col.pop = c(3:(as.numeric(model$I[1,3])+2)),
                   lwd.arrow = 2, size.scale = "log", log.base = 10,time.scale = "generation",
                   N4=as.numeric(x[[2]][length(x[[2]])]), axes = axes, xlab = xlab, ylab = ylab)
}

  }




#' Multiple plot function
#' @description Arrange multiple ggplot objects in a grid layout. ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects).
#' @param ... ggplot objects to arrange.
#' @param plotlist A list of ggplot objects. Alternative to passing plots in ...
#' @param file Unused. Kept for compatibility.
#' @param cols Number of columns in the layout. Default is 1.
#' @param layout A matrix specifying the layout. If present, 'cols' is ignored. For example, matrix(c(1,2,3,3), nrow=2, byrow=TRUE) places plot 1 upper left, plot 2 upper right, and plot 3 across the bottom.
#' @return Graphic
#' @export
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }

  if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}


#' Principal Component Analysis plot
#' @description plot first 10 PCs of simulated data against observed.
#' @param models A data.frame object with combined summary statistics.
#' @param index A character vector indexing the models object.
#' @param observed Observed summary statistics. Should be the same as in models.
#' @param subsample A number between 0-1 indicating a fraction of rows in the models object to be included in the PCA calculation.
#' @return graphic
#' @author Marcelo Gehara
#' @export
plotPCs <- function (models, index, observed, subsample) {

  labels <- unique(index)
  labels <- sort(c(labels,"observed"))
  sizes <- rep(2,length(labels))
  sizes[which(labels=="observed")]<-10

  shapes <- rep(16,length(labels))
  shapes[which(labels=="observed")]<-8

  # exclude missing data for pca plot
  data.PCA <- index[complete.cases(models)]
  models.PCA <- models[complete.cases(models),]
  # subsample for PCA
  x <- sample(1:length(data.PCA),length(data.PCA)*subsample)
  data.PCA <- data.PCA[x]
  models.PCA <- models.PCA[x,]
  # run PCA
  PCA <- prcomp(rbind(models.PCA, observed), center = T, scale. = T, retx=T)
  # get scores
  scores <- data.frame(PCA$x[,1:ncol(PCA$x)])
  PC <- colnames(scores)[1:10]
  plotPCA<-function(PCS){
    PCS <- rlang::sym(PCS)
    p <- ggplot2::ggplot(scores, ggplot2::aes(x = PC1, y = !! PCS )) +
      ggplot2::theme(legend.position = "none")+
      ggplot2::geom_point(ggplot2::aes(colour=c(data.PCA,"observed"), size=c(data.PCA,"observed"),
                                       shape=c(data.PCA,"observed")))+
      ggplot2::scale_shape_manual(values=shapes)+
      ggplot2::scale_size_manual(values=sizes)+
      ggplot2::scale_color_brewer(palette="Dark2")+
      if(PCS=="PC2") ggplot2::theme(legend.position="top", legend.direction="horizontal", legend.title = ggplot2::element_blank())
    return(p)
  }
  P<-NULL
  for(i in 2:10){
    P[[i]]  <- plotPCA(PC[i])
  }
  gridExtra::grid.arrange(P[[2]], P[[3]], P[[4]], P[[5]], P[[6]], P[[7]], P[[8]], P[[9]], P[[10]], nrow=3)
}



