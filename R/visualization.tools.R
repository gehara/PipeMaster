#' Plot simulated data against observed
#' @description This function plots an histogram of the simulated summary statistics with the corresponding observed value as a red line for comparison.
#' @param sim A data frame with simulated data.
#' @param obs A vector of observed summary stats corresponding to the sim object.
#' @return Graphic
#' @author Marcelo Gehara
#' @export
plot.sim.obs <- function(sim, obs)
  {
    mylabels <- colnames(sim)
    for (i in 1:ncol(sim)) {
      hist(sim[, i], breaks = 20, xlab = mylabels[i], main = "",
           xlim = c(min(c(na.omit(sim[, i]),obs[i])), max(c(na.omit(sim[, i]),obs[i]))))
      abline(v = obs[i], col = 2)
    }
  }

#' Plot prior distribution
#' @description This function plots a density of the simulated prior.
#' @param model A model object.
#' @param nsamples Number of samples to draw from each prior distribution.
#' @param mu.rates List. Distribution to sample the mutation rates. If NULL, rates are sampled from the model. See sim.sumstat for details.
#' @return Graphic
#' @author Marcelo Gehara
#' @export
plot.priors <- function(model, nsamples=1000, mu.rates=NULL){

  param = NULL
  pb = txtProgressBar(min = 1, max = nsamples, initial = 1)
  for(j in 1:nsamples){
    param.samples <- as.numeric(PipeMaster:::msABC.commander(model, use.alpha=F, arg=1)[[2]][2,])
    if(!(is.null(mu.rates))){
      rates <- do.call(mu.rates[[1]],args=c(1,mu.rates[2:length(mu.rates)]))
      param <- rbind(param,c(param.samples, rates))
      } else {
      rates <- PipeMaster:::sample.mu.rates(model)[[2]]
      param <- rbind(param,c(param.samples, rates))
    }
    setTxtProgressBar(pb,j)
  }
  if(!(is.null(mu.rates))){
    colnames(param) <- c(PipeMaster:::msABC.commander(model, use.alpha=F, arg=1)[[2]][1,],"mu")
  } else {
    colnames(param) <- c(PipeMaster:::msABC.commander(model, use.alpha=F, arg=1)[[2]][1,],"mean.mu", "sd.mu")
  }

  par(mfrow=c(3,3))
  for(i in 1:ncol(param)){
    plot(density(param[,i]), main=colnames(param)[i], col=2)
  }
}

#' Get a table with prior distributions.
#' @description This function makes a table with the parameters of the model and respective prior distribution.
#' @param model A model object.
#' @return A data frame with 4 columns: parameter name, first parameter of prior distribution, second parameter of prior distribution, prior distribution.
#' @author Marcelo Gehara
#' @export
get.prior.table <- function(model){

  flags <- model$flags

  for(i in 1:length(flags)){
    if(is.null(nrow(flags[[i]]))){
      flags[[i]] <- do.call(rbind,flags[[i]])
    }
  }
    flags <- do.call(rbind,flags)
    flags <- as.data.frame(flags[,c(1,4,5,6)])
    colnames(flags) <- c("Parameter","prior.1","prior.2","distribution")
    return(flags)
}

#' Update priors using a prior table
#' @description This function updates the prior of your models using a prior table. see get.prior.table function
#' @param tab A prior table generated by the get.prior.table function.
#' @param model A model object.
#' @return A data frame with 4 columns: parameter name, first parameter of prior distribution, second parameter of prior distribution, prior distribution.
#' @author Marcelo Gehara
#' @export
update.priors<-function(tab, model){

  for(i in 1:nrow(tab)){

    x <- model$flags[[grep(tab[i,1], model$flags)]]

    if(is.null(nrow(x))){
      y <- which(mapply(grep,paste0("^",tab[i,1],"$"),x)==1)
      x <- x[y]
      x <- x[[1]]
      x[grep(tab[i,1], x),4:6] <- as.matrix(tab[i, 2:4])
      model$flags[[grep(tab[i,1], model$flags)]][[y]]<-x
    } else {
      x[grep(tab[i,1], x),4:6] <- as.matrix(tab[i, 2:4])
      model$flags[[grep(tab[i,1], model$flags)]] <- x
    }

  }
  return(model)
}

#' Plot a 2D Joint Site Frequency Spectrum
#' @description Plots a 2D joint SFS as a heatmap with log10 color scale and colorbar,
#'              following the standard convention used by dadi and moments.
#'              Accepts either a matrix or a flattened vector (as output by sim.sfs for 2-population models).
#'              Zero entries are masked (shown as white). Pop 1 is on the y-axis and Pop 2 on the x-axis.
#' @param sfs A matrix (joint SFS) or numeric vector (flattened joint SFS from sim.sfs output).
#' @param pop_sizes Integer vector of length 2 with per-population sample sizes. Required when sfs is a vector.
#' @param pop_names Character vector of length 2 with population labels. Default is c("Pop 1", "Pop 2").
#' @param folded Logical. If TRUE, folds the SFS by combining entries (i,j) with their complement (n1-i, n2-j). Default is FALSE.
#' @param log Logical. If TRUE (default), uses log10 color scale.
#' @param col Color palette vector. Default uses a 256-color YlOrRd palette.
#' @param main Plot title. Default is "Joint SFS".
#' @param ... Additional arguments passed to image().
#' @examples
#' \dontrun{
#' # From sim.sfs output
#' sim.data <- read.table("SIM_SFS_model.txt", header = TRUE)
#' sfs_cols <- grep("^sfs_", colnames(sim.data))
#'
#' # Plot a single replicate (unfolded)
#' sfs_vec <- as.numeric(sim.data[1, sfs_cols])
#' plot.2D.sfs(sfs_vec, pop_sizes = c(64, 14))
#'
#' # Plot folded SFS
#' plot.2D.sfs(sfs_vec, pop_sizes = c(64, 14), folded = TRUE)
#'
#' # Plot average across replicates
#' avg_sfs <- colMeans(sim.data[, sfs_cols])
#' plot.2D.sfs(avg_sfs, pop_sizes = c(64, 14),
#'             pop_names = c("A. piscivorus", "A. conanti"))
#' }
#' @author Marcelo Gehara
#' @rawNamespace export(plot.2D.sfs)
plot.2D.sfs <- function(sfs, pop_sizes = NULL,
                         pop_names = c("Pop 1", "Pop 2"),
                         folded = FALSE,
                         log = TRUE,
                         col = NULL,
                         main = "Joint SFS", ...) {

  if(is.null(dim(sfs))) {
    if(is.null(pop_sizes) || length(pop_sizes) != 2) {
      stop("pop_sizes (integer vector of length 2) required when sfs is a vector.")
    }
    sfs <- matrix(as.numeric(sfs), nrow = pop_sizes[1] + 1, ncol = pop_sizes[2] + 1)
  }

  n1 <- nrow(sfs) - 1
  n2 <- ncol(sfs) - 1

  # Fold the SFS if requested
  if(folded) {
    sfs <- fold_2d_sfs(sfs)
    if(main == "Joint SFS") main <- "Folded Joint SFS"
  }

  # Default color palette
  if(is.null(col)) col <- hcl.colors(256, "YlOrRd", rev = TRUE)
  ncolors <- length(col)

  # Mask zeros (NA -> white in plot)
  sfs[sfs == 0] <- NA

  # Log10 transform
  if(log) sfs <- log10(sfs)

  zlim <- range(sfs, na.rm = TRUE)

  # Save and restore graphics state
  old_par <- par(no.readonly = TRUE)
  on.exit(par(old_par))

  # Layout: main plot + colorbar
  layout(matrix(c(1, 2), nrow = 1), widths = c(5, 1.2))

  # --- Main heatmap ---
  # Transpose so pop1 = y-axis, pop2 = x-axis (dadi/moments convention)
  par(mar = c(4.5, 4.5, 3, 0.5))
  image(0:n2, 0:n1, t(sfs),
        zlim = zlim, col = col,
        xlab = paste(pop_names[2], "derived allele count"),
        ylab = paste(pop_names[1], "derived allele count"),
        main = main,
        useRaster = TRUE, axes = FALSE, ...)
  axis(1)
  axis(2)
  box()

  # --- Colorbar ---
  par(mar = c(4.5, 0.5, 3, 3.5))
  bar_vals <- seq(zlim[1], zlim[2], length.out = ncolors)
  image(1, bar_vals, matrix(bar_vals, nrow = 1), col = col,
        axes = FALSE, xlab = "", ylab = "")
  if(log) {
    at_vals <- pretty(bar_vals)
    labels <- sapply(at_vals, function(x) as.expression(bquote(10^.(round(x, 1)))))
    axis(4, at = at_vals, labels = labels, las = 1)
  } else {
    axis(4, las = 1)
  }
  box()
}

# Internal helper: fold a 2D joint SFS
# Combines each entry (i,j) with its complement (n1-i, n2-j).
# The summed value is placed at whichever entry has the smaller total
# derived allele count (i+j). Entries in the upper half become zero.
fold_2d_sfs <- function(sfs) {
  n1 <- nrow(sfs) - 1
  n2 <- ncol(sfs) - 1
  folded <- matrix(0, nrow = n1 + 1, ncol = n2 + 1)
  processed <- matrix(FALSE, nrow = n1 + 1, ncol = n2 + 1)

  for(i in 0:n1) {
    for(j in 0:n2) {
      if(processed[i + 1, j + 1]) next
      mi <- n1 - i
      mj <- n2 - j
      if(i == mi && j == mj) {
        # Self-complementary entry
        folded[i + 1, j + 1] <- sfs[i + 1, j + 1]
      } else {
        # Sum the pair, place at the entry with smaller i+j
        val <- sfs[i + 1, j + 1] + sfs[mi + 1, mj + 1]
        if(i + j <= mi + mj) {
          folded[i + 1, j + 1] <- val
        } else {
          folded[mi + 1, mj + 1] <- val
        }
      }
      processed[i + 1, j + 1] <- TRUE
      processed[mi + 1, mj + 1] <- TRUE
    }
  }

  return(folded)
}

#' Plot model
#' @description This function plots a graphical representation of your demographic model
#'   as a tree diagram with rectangles whose widths are proportional to effective population size.
#'   Migration is shown as arrows between populations.
#' @param model A model object generated by main.menu() or main.menu.gui().
#' @param use.alpha Logical. If TRUE the most recent population size change will be exponential. If FALSE sudden demographic changes. Default is FALSE.
#'                  This argument is accepted for compatibility but does not affect the plot (the plot shows prior-sampled or average Ne values).
#' @param average.of.priors Logical. If TRUE, parameters for the plot are the conditional means of the priors (averaged over many samples respecting conditions). If FALSE, a single conditioned draw from the priors is used. Default is FALSE.
#' @param pop.labels Optional character vector of population labels (e.g. c("YRI","CEU")). If NULL (default), populations are labeled as "Pop 1", "Pop 2", etc.
#' @param ... Additional arguments (currently unused, kept for compatibility).
#' @return Produces a plot. Invisible NULL.
#' @author Marcelo Gehara
#' @export
PlotModel <- function(model, use.alpha=FALSE, average.of.priors=FALSE,
                      pop.labels=NULL, ...) {

  if(class(model) != "Model")
    stop("First argument should be an object of class Model.")

  npops <- as.integer(model$I[1, 3])

  # Convert Model object to the rv-like list used by the plot engine
  rv <- list(
    npops = npops,
    n = model$flags$n,
    en = model$flags$en,
    ej = model$flags$ej,
    m = model$flags$m,
    em = model$flags$em,
    size_matrix = model$conds$size.matrix,
    time_matrix = model$conds$time.matrix,
    mig_matrix  = model$conds$mig.matrix,
    pop_labels = if (!is.null(pop.labels)) pop.labels else as.character(1:npops)
  )

  # --- Helper functions for conditioned parameter sampling ---

  .apply_cond <- function(vals, cond_mat) {
    if (is.null(cond_mat) || is.null(vals) || length(vals) == 0) return(vals)
    nms <- intersect(names(vals), rownames(cond_mat))
    if (length(nms) == 0) return(vals)
    sub <- cond_mat[nms, nms, drop = FALSE]
    lt_idx <- which(sub == "<", arr.ind = TRUE)
    if (nrow(lt_idx) > 0) for (k in 1:nrow(lt_idx)) {
      n1 <- nms[lt_idx[k,1]]; n2 <- nms[lt_idx[k,2]]
      if (vals[n1] > vals[n2]) { tmp <- vals[n1]; vals[n1] <- vals[n2]; vals[n2] <- tmp }
    }
    gt_idx <- which(sub == ">", arr.ind = TRUE)
    if (nrow(gt_idx) > 0) for (k in 1:nrow(gt_idx)) {
      n1 <- nms[gt_idx[k,1]]; n2 <- nms[gt_idx[k,2]]
      if (vals[n1] < vals[n2]) { tmp <- vals[n1]; vals[n1] <- vals[n2]; vals[n2] <- tmp }
    }
    eq_idx <- which(sub == "=", arr.ind = TRUE)
    if (nrow(eq_idx) > 0) for (k in 1:nrow(eq_idx)) {
      n1 <- nms[eq_idx[k,1]]; n2 <- nms[eq_idx[k,2]]
      vals[n1] <- vals[n2]
    }
    vals
  }

  .sample_par_vec <- function(mat) {
    if (is.null(mat) || !is.matrix(mat) || nrow(mat) == 0) return(NULL)
    vals <- numeric(nrow(mat))
    for (i in 1:nrow(mat)) {
      v1 <- as.numeric(mat[i, 4]); v2 <- as.numeric(mat[i, 5])
      vals[i] <- stats::runif(1, v1, v2)
    }
    setNames(vals, mat[, 1])
  }

  .sample_all_conditioned <- function() {
    size_v <- c(.sample_par_vec(rv$n),
                if (!is.null(rv$en)) .sample_par_vec(rv$en$size))
    time_v <- c(if (!is.null(rv$ej) && is.matrix(rv$ej)) .sample_par_vec(rv$ej),
                if (!is.null(rv$en)) .sample_par_vec(rv$en$time),
                if (!is.null(rv$em)) .sample_par_vec(rv$em$time))
    mig_v  <- c(if (!is.null(rv$m) && is.matrix(rv$m)) .sample_par_vec(rv$m),
                if (!is.null(rv$em)) .sample_par_vec(rv$em$size))
    size_v <- .apply_cond(size_v, rv$size_matrix)
    time_v <- .apply_cond(time_v, rv$time_matrix)
    mig_v  <- .apply_cond(mig_v,  rv$mig_matrix)
    c(size_v, time_v, mig_v)
  }

  .conditioned_means <- function(n_samples = 500) {
    all_samp <- replicate(n_samples, .sample_all_conditioned())
    if (is.null(all_samp)) return(NULL)
    if (is.matrix(all_samp)) return(rowMeans(all_samp))
    setNames(mean(all_samp), names(.sample_all_conditioned()))
  }

  # --- Get parameter values ---
  cond_vals <- if (average.of.priors) .conditioned_means() else .sample_all_conditioned()
  if (is.null(cond_vals) || length(cond_vals) == 0) {
    plot.new(); text(0.5, 0.5, "No parameters to plot", cex = 1.5)
    return(invisible(NULL))
  }
  lookup <- function(name) unname(cond_vals[name])

  # Current Ne per population
  ne_current <- rep(100000, npops)
  if (!is.null(rv$n) && is.matrix(rv$n)) {
    for (i in 1:nrow(rv$n)) {
      pop_id <- as.integer(rv$n[i, 3])
      if (!is.na(pop_id) && pop_id >= 1 && pop_id <= npops)
        ne_current[pop_id] <- lookup(rv$n[i, 1])
    }
  }

  # Collect time-ordered events
  events <- list()
  if (!is.null(rv$ej) && is.matrix(rv$ej) && nrow(rv$ej) > 0) {
    for (i in 1:nrow(rv$ej)) {
      pair <- as.integer(strsplit(rv$ej[i, 3], " ")[[1]])
      events[[length(events) + 1]] <- list(type = "join", time = lookup(rv$ej[i, 1]),
                                            src = pair[1], tgt = pair[2])
    }
  }
  if (!is.null(rv$en) && !is.null(rv$en$size) && is.matrix(rv$en$size)) {
    for (i in 1:nrow(rv$en$size)) {
      events[[length(events) + 1]] <- list(type = "ne_change", time = lookup(rv$en$time[i, 1]),
                                            pop = as.integer(rv$en$size[i, 3]),
                                            ne = lookup(rv$en$size[i, 1]))
    }
  }
  if (length(events) > 0) events <- events[order(sapply(events, `[[`, "time"))]

  # Track state and build drawing segments
  x_pos  <- setNames(as.numeric(1:npops), as.character(1:npops))
  alive  <- setNames(rep(TRUE, npops), as.character(1:npops))
  cur_ne <- setNames(ne_current, as.character(1:npops))
  last_t <- setNames(rep(0, npops), as.character(1:npops))
  segs   <- list()
  merges <- list()

  for (ev in events) {
    if (ev$type == "ne_change") {
      p <- as.character(ev$pop)
      if (alive[p]) {
        segs[[length(segs) + 1]] <- list(pop = p, x = x_pos[p], t0 = last_t[p],
                                          t1 = ev$time, ne = cur_ne[p])
        cur_ne[p] <- ev$ne
        last_t[p] <- ev$time
      }
    } else if (ev$type == "join") {
      s <- as.character(ev$src); g <- as.character(ev$tgt)
      if (alive[s] && alive[g]) {
        segs[[length(segs) + 1]] <- list(pop = s, x = x_pos[s], t0 = last_t[s],
                                          t1 = ev$time, ne = cur_ne[s])
        segs[[length(segs) + 1]] <- list(pop = g, x = x_pos[g], t0 = last_t[g],
                                          t1 = ev$time, ne = cur_ne[g])
        new_x <- mean(c(x_pos[s], x_pos[g]))
        merges[[length(merges) + 1]] <- list(time = ev$time, x_src = x_pos[s],
                                              ne_src = cur_ne[s], x_tgt = x_pos[g],
                                              ne_tgt = cur_ne[g], x_new = new_x,
                                              ne_new = cur_ne[g])
        alive[s] <- FALSE
        x_pos[g] <- new_x
        last_t[g] <- ev$time
      }
    }
  }

  # Close remaining active lineages (root extension)
  all_t1  <- if (length(segs) > 0) sapply(segs, `[[`, "t1") else 0
  max_t   <- max(c(all_t1, 1))
  root_ext <- max_t * 0.25
  for (p in names(alive)) {
    if (alive[p])
      segs[[length(segs) + 1]] <- list(pop = p, x = x_pos[p], t0 = last_t[p],
                                        t1 = max_t + root_ext, ne = cur_ne[p])
  }

  # Scaling
  all_ne <- sapply(segs, `[[`, "ne")
  y_max  <- max(sapply(segs, `[[`, "t1"))
  ne_max <- max(all_ne); ne_min <- min(all_ne)
  hw_max <- 0.38; hw_min <- 0.06
  ne2hw <- function(ne) {
    if (ne_max == ne_min) return((hw_max + hw_min) / 2)
    hw_min + (hw_max - hw_min) * (ne - ne_min) / (ne_max - ne_min)
  }

  pal <- c("#4E79A7", "#F28E2B", "#E15759", "#76B7B2",
           "#59A14F", "#EDC948", "#B07AA1", "#FF9DA7",
           "#9C755F", "#BAB0AC")
  pcol <- function(p) pal[((as.integer(p) - 1) %% length(pal)) + 1]
  delta <- y_max * 0.015

  # Plot area
  all_x <- unlist(lapply(segs, function(s) c(s$x - ne2hw(s$ne), s$x + ne2hw(s$ne))))
  x_lo <- min(all_x) - 0.3; x_hi <- max(all_x) + 0.3

  par(mar = c(3.5, 5, 2.5, 1.5), bg = "#222222", fg = "white",
      col.axis = "#cccccc", col.lab = "#cccccc", col.main = "white")
  plot(NULL, xlim = c(x_lo, x_hi), ylim = c(-y_max * 0.07, y_max),
       xlab = "", ylab = "Time (generations ago)",
       main = "", axes = FALSE)
  axis(2, las = 1, col = "#666666", col.ticks = "#666666", col.axis = "#cccccc")

  # Merge connectors
  for (mg in merges) {
    hw_s <- ne2hw(mg$ne_src); hw_t <- ne2hw(mg$ne_tgt); hw_n <- ne2hw(mg$ne_new)
    if (mg$x_src < mg$x_tgt) {
      lx <- mg$x_src; lhw <- hw_s; rx <- mg$x_tgt; rhw <- hw_t
    } else {
      lx <- mg$x_tgt; lhw <- hw_t; rx <- mg$x_src; rhw <- hw_s
    }
    nx <- mg$x_new; nhw <- hw_n
    polygon(x = c(lx - lhw, lx + lhw, nx, nx - nhw),
            y = c(mg$time, mg$time, mg$time + delta, mg$time + delta),
            col = adjustcolor("#888888", 0.5), border = NA)
    polygon(x = c(rx - rhw, rx + rhw, nx + nhw, nx),
            y = c(mg$time, mg$time, mg$time + delta, mg$time + delta),
            col = adjustcolor("#888888", 0.5), border = NA)
  }

  # Population rectangles
  for (seg in segs) {
    hw <- ne2hw(seg$ne); col <- pcol(seg$pop)
    rect(seg$x - hw, seg$t0, seg$x + hw, seg$t1,
         col = adjustcolor(col, alpha.f = 0.75),
         border = adjustcolor(col, alpha.f = 0.9), lwd = 1.5)
  }

  # Population labels
  labels <- rv$pop_labels
  for (i in 1:npops) {
    text(i, -y_max * 0.04, paste0("Pop ", labels[i]),
         col = pcol(as.character(i)), cex = 0.9, font = 2)
  }

  # Ne annotations
  for (seg in segs) {
    if ((seg$t1 - seg$t0) > y_max * 0.05)
      text(seg$x, (seg$t0 + seg$t1) / 2, format(round(seg$ne), big.mark = ","),
           col = "white", cex = 0.55, srt = 90)
  }

  # Time annotations
  for (mg in merges)
    text(x_hi - 0.05, mg$time, format(round(mg$time), big.mark = ","),
         col = "#aaaaaa", cex = 0.7, adj = c(1, 0.5))

  # Migration arrows
  if (!is.null(rv$m) && is.matrix(rv$m) && nrow(rv$m) > 0) {
    leaf_segs <- list()
    for (seg in segs) if (seg$t0 == 0) leaf_segs[[seg$pop]] <- seg
    for (i in 1:nrow(rv$m)) {
      pair <- as.integer(strsplit(rv$m[i, 3], " ")[[1]])
      from_p <- as.character(pair[1]); to_p <- as.character(pair[2])
      if (is.null(leaf_segs[[from_p]]) || is.null(leaf_segs[[to_p]])) next
      seg_from <- leaf_segs[[from_p]]; seg_to <- leaf_segs[[to_p]]
      hw_from <- ne2hw(seg_from$ne); hw_to <- ne2hw(seg_to$ne)
      arr_y <- min(seg_from$t1, seg_to$t1) * 0.33
      if (seg_from$x < seg_to$x) {
        x0 <- seg_from$x + hw_from; x1 <- seg_to$x - hw_to
      } else {
        x0 <- seg_from$x - hw_from; x1 <- seg_to$x + hw_to
      }
      y_off <- if (pair[1] < pair[2]) y_max * 0.012 else -y_max * 0.012
      arrows(x0, arr_y + y_off, x1, arr_y + y_off,
             col = "#FFD700", lwd = 1.8, length = 0.08, code = 2)
      mig_val <- lookup(rv$m[i, 1])
      text((x0 + x1) / 2, arr_y + y_off + y_max * 0.018,
           sprintf("%.2g", mig_val), col = "#FFD700", cex = 0.5)
    }
  }

  invisible(NULL)
}




#' Multiple plot function
#' @description Arrange multiple ggplot objects in a grid layout. ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects).
#' @param ... ggplot objects to arrange.
#' @param plotlist A list of ggplot objects. Alternative to passing plots in ...
#' @param file Unused. Kept for compatibility.
#' @param cols Number of columns in the layout. Default is 1.
#' @param layout A matrix specifying the layout. If present, 'cols' is ignored. For example, matrix(c(1,2,3,3), nrow=2, byrow=TRUE) places plot 1 upper left, plot 2 upper right, and plot 3 across the bottom.
#' @return Graphic
#' @export
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }

  if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}


#' Principal Component Analysis plot
#' @description plot first 10 PCs of simulated data against observed.
#' @param models A data.frame object with combined summary statistics.
#' @param index A character vector indexing the models object.
#' @param observed Observed summary statistics. Should be the same as in models.
#' @param subsample A number between 0-1 indicating a fraction of rows in the models object to be included in the PCA calculation.
#' @return graphic
#' @author Marcelo Gehara
#' @export
plotPCs <- function (models, index, observed, subsample) {

  labels <- unique(index)
  labels <- sort(c(labels,"observed"))
  sizes <- rep(2,length(labels))
  sizes[which(labels=="observed")]<-10

  shapes <- rep(16,length(labels))
  shapes[which(labels=="observed")]<-8

  # exclude missing data for pca plot
  data.PCA <- index[complete.cases(models)]
  models.PCA <- models[complete.cases(models),]
  # subsample for PCA
  x <- sample(1:length(data.PCA),length(data.PCA)*subsample)
  data.PCA <- data.PCA[x]
  models.PCA <- models.PCA[x,]
  # run PCA
  PCA <- prcomp(rbind(models.PCA, observed), center = T, scale. = T, retx=T)
  # get scores
  scores <- data.frame(PCA$x[,1:ncol(PCA$x)])
  PC <- colnames(scores)[1:10]
  plotPCA<-function(PCS){
    PCS <- rlang::sym(PCS)
    p <- ggplot2::ggplot(scores, ggplot2::aes(x = PC1, y = !! PCS )) +
      ggplot2::theme(legend.position = "none")+
      ggplot2::geom_point(ggplot2::aes(colour=c(data.PCA,"observed"), size=c(data.PCA,"observed"),
                                       shape=c(data.PCA,"observed")))+
      ggplot2::scale_shape_manual(values=shapes)+
      ggplot2::scale_size_manual(values=sizes)+
      ggplot2::scale_color_brewer(palette="Dark2")+
      if(PCS=="PC2") ggplot2::theme(legend.position="top", legend.direction="horizontal", legend.title = ggplot2::element_blank())
    return(p)
  }
  P<-NULL
  for(i in 2:10){
    P[[i]]  <- plotPCA(PC[i])
  }
  gridExtra::grid.arrange(P[[2]], P[[3]], P[[4]], P[[5]], P[[6]], P[[7]], P[[8]], P[[9]], P[[10]], nrow=3)
}



