#' Simulate Site Frequency Spectra using scrm
#' @description This function simulates the Site Frequency Spectrum (SFS) using the scrm coalescent simulator.
#'              For single-population models, it outputs the 1D SFS (unfolded or folded) summed across loci.
#'              For multi-population models, it computes the joint SFS from segregating sites,
#'              returning the flattened multi-dimensional array (e.g., (n1+1)*(n2+1) entries for 2 pops).
#'              Suitable for inference with fastsimcoal2, dadi, moments, etc.
#' @param model A model object built by the main.menu function.
#' @param use.alpha Logical. If TRUE the most recent population size change will be exponential. If FALSE sudden demographic changes. Default is FALSE.
#' @param nsim.blocks Number of blocks to simulate. The total number of simulations is: nsim.blocks x block.size (x ncores when ncores > 1).
#' @param block.size Simulations are performed in blocks. This argument defines the size of the block in number of simulations, i.e. how many simulations to run per block.
#'                   A block of 1000 will work for most cases. Increase the total number of simulations with nsim.blocks argument.
#' @param path Path to write the output. By default outputs will be saved in the working directory.
#' @param output.name String. The prefix of the output names. Default is "model".
#' @param append.sims Logical. If TRUE simulations will be appended in the last output. Default is FALSE.
#' @param mu.rates List. Distribution to sample the mutation rates. The first element of the list should be the name of the distribution as a character string.
#'                 The second element of the list must be the number of loci. The following elements are the parameters of the distribution.
#'                 Ex.: mu.rates = list("rtnorm", 1000, 1e-9, 1e-9, 0). If NULL, rates are sampled from the model priors. Default is NULL.
#' @param folded Logical. If TRUE the SFS will be folded. Default is FALSE.
#' @param ncores Number of cores for parallel execution. When ncores > 1, separate R worker processes are spawned. Default is 1.
#' @return Writes SIM_SFS_{output.name}.txt to the path directory. The file contains a header row followed by one row per replicate, with parameter values (including mean.rate and sd.rate) and SFS bins.
#' @examples
#' \dontrun{
#' # Load example demographic models
#' data("A_piscivorus", package = "PipeMaster")
#'
#' # Optimize model for uniform sample sizes
#' Is_opt <- optimize.sfs.model(Is)
#'
#' # Quick test run (small block size, single core)
#' tmpdir <- tempdir()
#' sim.sfs(model = Is_opt,
#'         nsim.blocks = 1,
#'         block.size = 10,
#'         path = tmpdir,
#'         use.alpha = FALSE,
#'         output.name = "test_sfs",
#'         ncores = 1)
#'
#' # Read simulated SFS
#' sim.data <- read.table(file.path(tmpdir, "SIM_SFS_test_sfs.txt"), header = TRUE)
#' head(sim.data)
#'
#' # Folded SFS
#' sim.sfs(model = Is_opt,
#'         nsim.blocks = 1,
#'         block.size = 10,
#'         path = tmpdir,
#'         use.alpha = FALSE,
#'         output.name = "test_sfs_folded",
#'         folded = TRUE,
#'         ncores = 1)
#' }
#' @author Marcelo Gehara
#' @export
sim.sfs <- function(model, use.alpha=FALSE, nsim.blocks=5, block.size=1000,
                          path=getwd(), output.name="model", append.sims=FALSE,
                          mu.rates=NULL, folded=FALSE, ncores=1) {

  WD <- getwd()

  if(class(model) != "Model") {
    stop("First argument should be an object of class Model generated by the main.menu() function.")
  }

  # Validate uniform per-population sample sizes across all loci
  npop <- as.numeric(model$I[1, 3])
  pop_cols <- 4:(3 + npop)
  pop_sizes <- matrix(as.numeric(model$I[, pop_cols]), ncol = npop)
  if(nrow(unique(pop_sizes)) > 1) {
    stop("All loci must have uniform per-population sample sizes for SFS simulation.\n",
         "  Use optimize.sfs.model() to downsample your model to uniform sample sizes first.")
  }

  setwd(path)
  on.exit(setwd(WD))

  ############### Header: discover SFS dimensions and write column names
  if(append.sims == FALSE) {
    com <- PipeMaster:::ms.commander2(model, use.alpha = use.alpha)

    # parameter names: keep non-rate params, replace per-locus rates with mean.rate + sd.rate
    par.names <- com[[nrow(model$loci) + 1]][1, ]
    par.names <- par.names[-length(par.names)]  # drop scalar
    rate.idx <- which(par.names %in% model$loci[,1])
    if(length(rate.idx) > 0) {
      par.names <- c(par.names[-rate.idx], "mean.rate", "sd.rate")
    }

    # SFS column names
    if(npop == 1) {
      # Single pop: discover SFS dimensions from test scrm call
      nsam <- sum(as.numeric(model$I[1, 4:ncol(model$I)]))
      test.result <- scrm::scrm(paste(nsam, 1, com[[1]], "-oSFS"))
      sfs.test <- as.numeric(test.result$sfs)
      if(folded) {
        folded.sfs <- fold_sfs(sfs.test)
        sfs.names <- paste0("sfs_fold_", seq(0, length(folded.sfs) - 1))
      } else {
        sfs.names <- paste0("sfs_", seq(0, length(sfs.test) - 1))
      }
    } else {
      # Multi-pop: joint SFS dimensions from per-population sample sizes
      pop_sizes_vec <- as.integer(model$I[1, pop_cols])
      idx_grid <- expand.grid(lapply(pop_sizes_vec, function(n) 0:n))
      sfs.names <- apply(idx_grid, 1, function(x) paste0("sfs_", paste(x, collapse = "_")))
    }

    nam <- c(par.names, sfs.names)
    write.table(t(nam), file = paste0("SIM_SFS_", output.name, ".txt"),
                quote = FALSE, row.names = FALSE, col.names = FALSE,
                append = FALSE, sep = "\t")
  }

  ############### Multi-core path
  if(ncores > 1) {
    abs.path <- normalizePath(getwd())
    save(model, nsim.blocks, block.size, use.alpha, output.name, mu.rates, folded,
         file = file.path(abs.path, ".PM_worker_params.RData"))

    worker_script <- paste(
      'args <- commandArgs(TRUE)',
      'worker_id <- as.integer(args[1])',
      'suppressMessages(library(PipeMaster))',
      sprintf('base_path <- "%s"', abs.path),
      'load(file.path(base_path, ".PM_worker_params.RData"))',
      'worker_dir <- file.path(base_path, paste0(".worker_", worker_id))',
      'dir.create(worker_dir, showWarnings=FALSE)',
      'sim.sfs(model=model, nsim.blocks=nsim.blocks, block.size=block.size,',
      '             path=worker_dir, use.alpha=use.alpha, mu.rates=mu.rates, folded=folded,',
      '             append.sims=TRUE,',
      '             output.name=output.name, ncores=1)',
      'write("done", file.path(base_path, paste0(".worker_", worker_id, ".done")))',
      'quit(save="no")',
      sep = "\n")
    writeLines(worker_script, file.path(abs.path, ".PM_worker.R"))

    start.time <- Sys.time()
    for(w in 1:ncores) {
      system(paste("Rscript", file.path(abs.path, ".PM_worker.R"), w,
                   ">", file.path(abs.path, paste0(".worker_", w, ".log")), "2>&1"),
             wait = FALSE)
    }
    cat(paste("PipeMaster:: Launched", ncores, "worker processes"), "\n")

    total_expected <- nsim.blocks * block.size * ncores
    while(TRUE) {
      Sys.sleep(5)
      done_count <- sum(file.exists(file.path(abs.path, paste0(".worker_", 1:ncores, ".done"))))

      total_sims <- 0
      for(w in 1:ncores) {
        wf <- file.path(abs.path, paste0(".worker_", w), paste0("SIM_SFS_", output.name, ".txt"))
        if(file.exists(wf)) {
          n <- length(readLines(wf))
          if(n > 0) total_sims <- total_sims + n
        }
      }

      elapsed_h <- as.numeric(difftime(Sys.time(), start.time, units = "hours"))
      if(total_sims > 0 && elapsed_h > 0) {
        rate <- total_sims / elapsed_h
        remaining <- round(max(0, (total_expected - total_sims) / rate), 3)
        cat(paste0("PipeMaster:: ", total_sims, " of ", total_expected,
                   " (~", round(rate), " sims/h) | ~", remaining,
                   " hours remaining | ", done_count, "/", ncores, " workers done"), "\n")
      }
      if(done_count >= ncores) break
    }

    cat("Compiling results from workers", sep = "\n")
    outfile <- file.path(abs.path, paste0("SIM_SFS_", output.name, ".txt"))
    for(w in 1:ncores) {
      wf <- file.path(abs.path, paste0(".worker_", w), paste0("SIM_SFS_", output.name, ".txt"))
      if(file.exists(wf)) {
        worker_data <- readLines(wf)
        if(length(worker_data) > 0) {
          cat(paste(worker_data, collapse = "\n"), "\n", file = outfile, append = TRUE, sep = "")
        }
      }
      unlink(file.path(abs.path, paste0(".worker_", w)), recursive = TRUE)
      f <- file.path(abs.path, paste0(".worker_", w, ".done"))
      if(file.exists(f)) file.remove(f)
    }
    file.remove(file.path(abs.path, ".PM_worker_params.RData"))
    file.remove(file.path(abs.path, ".PM_worker.R"))
    for(w in 1:ncores) {
      f <- file.path(abs.path, paste0(".worker_", w, ".log"))
      if(file.exists(f)) file.remove(f)
    }

    end.time <- Sys.time()
    elapsed_h <- as.numeric(difftime(end.time, start.time, units = "hours"))
    cat(paste0("PipeMaster:: Done! ", total_expected, " simulations in ",
               round(elapsed_h, 3), " hours (~", round(total_expected / elapsed_h), " sims/h)"), "\n")

  } else {
    ############### Single-core path
    sim.sfs.func <- function() {
      results <- NULL
      for(i in 1:block.size) {
        com <- PipeMaster:::ms.commander2(model, use.alpha = use.alpha)

        # override mutation rates if mu.rates is provided
        if(!is.null(mu.rates)) {
          user.rates <- do.call(mu.rates[[1]], args = mu.rates[2:length(mu.rates)])
          n_loci <- nrow(model$loci)
          if(length(user.rates) < n_loci) user.rates <- rep_len(user.rates, n_loci)
          # get scalar from parameter matrix
          par.all <- com[[n_loci + 1]]
          ms.scalar <- as.numeric(par.all[2, ncol(par.all)])
          # replace -t value in each locus command
          for(u in 1:n_loci) {
            bp <- as.numeric(model$loci[u, 2])
            new.theta <- ms.scalar * user.rates[u] * bp
            com[[u]] <- sub("-t\\s+[0-9.eE+\\-]+", paste("-t", new.theta), com[[u]])
          }
          # replace rate values in parameter matrix
          rate.rows <- which(par.all[1, ] %in% model$loci[,1])
          for(r in seq_along(rate.rows)) {
            par.all[2, rate.rows[r]] <- as.character(user.rates[r])
          }
          com[[n_loci + 1]] <- par.all
        }

        # collect and sum SFS across loci
        nsam <- sum(as.numeric(model$I[1, 4:ncol(model$I)]))
        if(npop == 1) {
          # Single pop: use -oSFS
          sfs.list <- list()
          for(u in 1:nrow(model$loci)) {
            scrm.out <- scrm::scrm(paste(nsam, 1, com[[u]], "-oSFS"))
            sfs.list[[u]] <- as.numeric(scrm.out$sfs)
          }
          sfs.mat <- do.call("rbind", sfs.list)
          sfs.mean <- colSums(sfs.mat, na.rm = TRUE)
          if(folded) sfs.mean <- fold_sfs(sfs.mean)
        } else {
          # Multi-pop: compute joint SFS from segregating sites
          pop_sizes_vec <- as.integer(model$I[1, pop_cols])
          joint_sfs <- array(0L, dim = pop_sizes_vec + 1L)
          for(u in 1:nrow(model$loci)) {
            scrm.out <- scrm::scrm(paste(nsam, 1, com[[u]]))
            seg <- scrm.out$seg_sites[[1]]
            if(ncol(seg) > 0) {
              joint_sfs <- joint_sfs + compute_joint_sfs(seg, pop_sizes_vec)
            }
          }
          sfs.mean <- as.vector(joint_sfs)
        }

        # extract parameters (drop scalar column)
        par <- com[[nrow(model$loci) + 1]][2, ]
        par <- par[-length(par)]  # drop scalar
        par.names.tmp <- com[[nrow(model$loci) + 1]][1, ]
        par.names.tmp <- par.names.tmp[-length(par.names.tmp)]
        rate.idx <- which(par.names.tmp %in% model$loci[,1])
        if(length(rate.idx) > 0) {
          rates <- as.numeric(par[rate.idx])
          par <- c(par[-rate.idx], mean(rates), sd(rates))
        }

        results <- rbind(results, c(par, sfs.mean))
      }
      data.frame(results)
    }

    total.sims <- 0
    for(k in 1:nsim.blocks) {
      start.time <- Sys.time()
      simulations <- sim.sfs.func()

      cat("Writing simulations to file", sep = "\n")
      write.table(simulations, file = paste0("SIM_SFS_", output.name, ".txt"),
                  quote = FALSE, row.names = FALSE, col.names = FALSE,
                  append = TRUE, sep = "\t")

      end.time <- Sys.time()
      total.sims <- total.sims + block.size
      cycle.time <- (as.numeric(end.time) - as.numeric(start.time)) / 60 / 60
      total.time <- cycle.time * nsim.blocks
      passed.time <- cycle.time * k
      remaining.time <- round(total.time - passed.time, 3)
      cat(paste("PipeMaster:: ", total.sims, " (~", round(block.size / cycle.time),
                " sims/h) | ~", remaining.time, " hours remaining", sep = ""), "\n")
    }
    print("Done!")
  }
}


# Internal helper: fold an SFS vector
# sfs has n = nsam-1 entries (frequency classes 1 to nsam-1, monomorphic excluded)
# Pairs frequency k with frequency nsam-k (i.e., index i with index n-i+1)
# When n is odd (nsam even), the middle entry is self-paired
fold_sfs <- function(sfs) {
  n <- length(sfs)
  half <- floor(n / 2)
  folded <- numeric(half)
  for(i in 1:half) {
    folded[i] <- sfs[i] + sfs[n - i + 1]
  }
  if(n %% 2 == 1) {
    folded <- c(folded, sfs[half + 1])
  }
  folded
}

# Internal helper: compute joint SFS from a seg_sites matrix for multi-pop models
# seg_sites: nsam x n_snps matrix (0/1) with rows ordered by population
# pop_sizes: integer vector of per-population sample sizes
# Returns: array of dimensions (n1+1) x (n2+1) x ... with SNP counts per joint frequency bin
compute_joint_sfs <- function(seg_sites, pop_sizes) {
  npop <- length(pop_sizes)
  dims <- pop_sizes + 1L

  if(ncol(seg_sites) == 0) return(array(0L, dim = dims))

  cum_sizes <- cumsum(c(0L, pop_sizes))

  # Count derived alleles per population for each SNP
  pop_counts <- matrix(0L, nrow = ncol(seg_sites), ncol = npop)
  for(p in 1:npop) {
    rows <- (cum_sizes[p] + 1):cum_sizes[p + 1]
    pop_counts[, p] <- colSums(seg_sites[rows, , drop = FALSE])
  }

  # Build joint SFS using table with proper factor levels
  args <- lapply(1:npop, function(p) factor(pop_counts[, p], levels = 0:pop_sizes[p]))
  sfs_table <- do.call(table, args)

  return(array(as.integer(sfs_table), dim = dims))
}
