#' Simulate Site Frequency Spectra
#' @description This function simulates the Site Frequency Spectrum (SFS) using the built-in
#'              coalescent simulator (ms/msABC). SFS computation is performed natively in C for speed.
#'              For single-population models, it outputs the 1D SFS (unfolded or folded) summed across loci.
#'              For multi-population models, it computes the joint SFS from segregating sites,
#'              returning the flattened multi-dimensional array (e.g., (n1+1)*(n2+1) entries for 2 pops).
#'              Suitable for inference with fastsimcoal2, dadi, moments, etc.
#' @param model A model object built by the main.menu function.
#' @param use.alpha Logical. If TRUE the most recent population size change will be exponential. If FALSE sudden demographic changes. Default is FALSE.
#' @param nsim.blocks Number of blocks to simulate. The total number of simulations is: nsim.blocks x block.size (x ncores when ncores > 1).
#' @param block.size Simulations are performed in blocks. This argument defines the size of the block in number of simulations, i.e. how many simulations to run per block.
#'                   A block of 1000 will work for most cases. Increase the total number of simulations with nsim.blocks argument.
#' @param path Path to write the output. By default outputs will be saved in the working directory.
#' @param output.name String. The prefix of the output names. Default is "model".
#' @param append.sims Logical. If TRUE simulations will be appended in the last output. Default is FALSE.
#' @param mu.rates List. Distribution to sample the mutation rates. The first element of the list should be the name of the distribution as a character string.
#'                 The second element of the list must be the number of loci. The following elements are the parameters of the distribution.
#'                 Ex.: mu.rates = list("rtnorm", 1000, 1e-9, 1e-9, 0). If NULL, rates are sampled from the model priors. Default is NULL.
#' @param one.snp Logical. If TRUE, one segregating site is randomly sampled per locus before
#'                computing the SFS. This reduces variance inflation caused by linkage among
#'                sites within the same locus. Recommended for short loci where recombination
#'                is negligible. Default is FALSE.
#' @param folded Logical. If TRUE the SFS will be folded. Default is FALSE.
#' @param ncores Number of cores for parallel execution. When ncores > 1, separate R worker processes are spawned. Default is 1.
#' @return Writes SIM_SFS_{output.name}.txt to the path directory. The file contains a header row followed by one row per replicate, with parameter values (including mean.rate and sd.rate) and SFS bins.
#' @examples
#' \dontrun{
#' # Load example demographic models
#' data("A_piscivorus", package = "PipeMaster")
#'
#' # Optimize model for uniform sample sizes
#' Is_opt <- optimize.sfs.model(Is)
#'
#' # Quick test run (small block size, single core)
#' tmpdir <- tempdir()
#' sim.sfs(model = Is_opt,
#'         nsim.blocks = 1,
#'         block.size = 10,
#'         path = tmpdir,
#'         use.alpha = FALSE,
#'         output.name = "test_sfs",
#'         ncores = 1)
#'
#' # Read simulated SFS
#' sim.data <- read.table(file.path(tmpdir, "SIM_SFS_test_sfs.txt"), header = TRUE)
#' head(sim.data)
#'
#' # Folded SFS
#' sim.sfs(model = Is_opt,
#'         nsim.blocks = 1,
#'         block.size = 10,
#'         path = tmpdir,
#'         use.alpha = FALSE,
#'         output.name = "test_sfs_folded",
#'         folded = TRUE,
#'         ncores = 1)
#' }
#' @author Marcelo Gehara
#' @export
sim.sfs <- function(model, use.alpha=FALSE, nsim.blocks=5, block.size=1000,
                          path=getwd(), output.name="model", append.sims=FALSE,
                          mu.rates=NULL, one.snp=FALSE, folded=FALSE, ncores=1) {

  WD <- getwd()

  if(class(model) != "Model") {
    stop("First argument should be an object of class Model generated by the main.menu() function.")
  }

  # Validate uniform per-population sample sizes across all loci
  npop <- as.numeric(model$I[1, 3])
  pop_cols <- 4:(3 + npop)
  pop_sizes_mat <- matrix(as.numeric(model$I[, pop_cols]), ncol = npop)
  if(nrow(unique(pop_sizes_mat)) > 1) {
    stop("All loci must have uniform per-population sample sizes for SFS simulation.\n",
         "  Use optimize.sfs.model() to downsample your model to uniform sample sizes first.")
  }

  pop_sizes_vec <- as.integer(pop_sizes_mat[1, ])
  nsam <- sum(pop_sizes_vec)
  setwd(path)
  on.exit(setwd(WD))

  ############### Header: discover SFS dimensions and write column names
  if(append.sims == FALSE) {
    # Get parameter names via msABC.commander (calls ms.string.generator only once)
    com <- PipeMaster:::msABC.commander(model, use.alpha = use.alpha, arg = 1)
    par.names <- c(com[[2]][1, ], "mean.rate", "sd.rate")

    # SFS column names (determined from sample sizes, no test simulation needed)
    if(npop == 1) {
      sfs_len <- nsam - 1  # freq bins 1..nsam-1
      if(folded) {
        folded_len <- length(fold_sfs(numeric(sfs_len)))
        sfs.names <- paste0("sfs_fold_", seq(0, folded_len - 1))
      } else {
        sfs.names <- paste0("sfs_", seq(0, sfs_len - 1))
      }
    } else {
      idx_grid <- expand.grid(lapply(pop_sizes_vec, function(n) 0:n))
      sfs.names <- apply(idx_grid, 1, function(x) paste0("sfs_", paste(x, collapse = "_")))
    }

    nam <- c(par.names, sfs.names)
    write.table(t(nam), file = paste0("SIM_SFS_", output.name, ".txt"),
                quote = FALSE, row.names = FALSE, col.names = FALSE,
                append = FALSE, sep = "\t")
  }

  ############### Multi-core path
  if(ncores > 1) {
    abs.path <- normalizePath(getwd())
    save(model, nsim.blocks, block.size, use.alpha, output.name, mu.rates, one.snp, folded,
         file = file.path(abs.path, ".PM_worker_params.RData"))

    worker_script <- paste(
      'args <- commandArgs(TRUE)',
      'worker_id <- as.integer(args[1])',
      'suppressMessages(library(PipeMaster))',
      sprintf('base_path <- "%s"', abs.path),
      'load(file.path(base_path, ".PM_worker_params.RData"))',
      'worker_dir <- file.path(base_path, paste0(".worker_", worker_id))',
      'dir.create(worker_dir, showWarnings=FALSE)',
      'sim.sfs(model=model, nsim.blocks=nsim.blocks, block.size=block.size,',
      '             path=worker_dir, use.alpha=use.alpha, mu.rates=mu.rates,',
      '             one.snp=one.snp, folded=folded,',
      '             append.sims=TRUE,',
      '             output.name=output.name, ncores=1)',
      'write("done", file.path(base_path, paste0(".worker_", worker_id, ".done")))',
      'quit(save="no")',
      sep = "\n")
    writeLines(worker_script, file.path(abs.path, ".PM_worker.R"))

    start.time <- Sys.time()
    for(w in 1:ncores) {
      system(paste("Rscript", file.path(abs.path, ".PM_worker.R"), w,
                   ">", file.path(abs.path, paste0(".worker_", w, ".log")), "2>&1"),
             wait = FALSE)
    }
    cat(paste("PipeMaster:: Launched", ncores, "worker processes"), "\n")

    total_expected <- nsim.blocks * block.size * ncores
    while(TRUE) {
      Sys.sleep(5)
      done_count <- sum(file.exists(file.path(abs.path, paste0(".worker_", 1:ncores, ".done"))))

      total_sims <- 0
      for(w in 1:ncores) {
        wf <- file.path(abs.path, paste0(".worker_", w), paste0("SIM_SFS_", output.name, ".txt"))
        if(file.exists(wf)) {
          n <- length(readLines(wf))
          if(n > 0) total_sims <- total_sims + n
        }
      }

      elapsed_h <- as.numeric(difftime(Sys.time(), start.time, units = "hours"))
      if(total_sims > 0 && elapsed_h > 0) {
        rate <- total_sims / elapsed_h
        remaining <- round(max(0, (total_expected - total_sims) / rate), 3)
        cat(paste0("PipeMaster:: ", total_sims, " of ", total_expected,
                   " (~", round(rate), " sims/h) | ~", remaining,
                   " hours remaining | ", done_count, "/", ncores, " workers done"), "\n")
      }
      if(done_count >= ncores) break
    }

    cat("Compiling results from workers", sep = "\n")
    outfile <- file.path(abs.path, paste0("SIM_SFS_", output.name, ".txt"))
    for(w in 1:ncores) {
      wf <- file.path(abs.path, paste0(".worker_", w), paste0("SIM_SFS_", output.name, ".txt"))
      if(file.exists(wf)) {
        worker_data <- readLines(wf)
        if(length(worker_data) > 0) {
          cat(paste(worker_data, collapse = "\n"), "\n", file = outfile, append = TRUE, sep = "")
        }
      }
      unlink(file.path(abs.path, paste0(".worker_", w)), recursive = TRUE)
      f <- file.path(abs.path, paste0(".worker_", w, ".done"))
      if(file.exists(f)) file.remove(f)
    }
    file.remove(file.path(abs.path, ".PM_worker_params.RData"))
    file.remove(file.path(abs.path, ".PM_worker.R"))
    for(w in 1:ncores) {
      f <- file.path(abs.path, paste0(".worker_", w, ".log"))
      if(file.exists(f)) file.remove(f)
    }

    end.time <- Sys.time()
    elapsed_h <- as.numeric(difftime(end.time, start.time, units = "hours"))
    cat(paste0("PipeMaster:: Done! ", total_expected, " simulations in ",
               round(elapsed_h, 3), " hours (~", round(total_expected / elapsed_h), " sims/h)"), "\n")

  } else {
    ############### Single-core path (native C SFS with msABC fragment mode)

    locfile <- PipeMaster:::get.locfile(model)
    nloci_rows <- nrow(locfile)

    sim.sfs.func <- function() {
      # Pre-sample all parameters for the block (no disk I/O in this loop)
      commands <- character(block.size)
      mu_mat <- matrix(0, nrow = nloci_rows, ncol = block.size)
      par_list <- vector("list", block.size)

      for(i in 1:block.size) {
        if(!is.null(mu.rates)) {
          rates <- do.call(mu.rates[[1]], args = mu.rates[2:length(mu.rates)])
          rates <- rep(rates, each = npop)
          rates <- list(rates, c(0, 0))
        } else {
          rates <- PipeMaster:::sample.mu.rates(model)
        }
        mu_mat[, i] <- rates[[1]]

        com <- PipeMaster:::msABC.commander(model, use.alpha = use.alpha, arg = 1)
        commands[i] <- com[[1]]
        par_list[[i]] <- c(com[[2]][2, ], rates[[2]][1], rates[[2]][2])
      }

      # Write locfile ONCE (static data; mu column overridden in C)
      write.table(locfile, ".1locfile.txt", row.names = FALSE, col.names = TRUE,
                  quote = FALSE, sep = " ")

      # Single C call processes entire block (no per-sim disk I/O)
      sfs_mat <- .Call("msABC_sfs_batch_call", commands, mu_mat,
                       pop_sizes_vec, one.snp, PACKAGE = "PipeMaster")

      if(folded && npop == 1) {
        sfs_mat <- t(apply(sfs_mat, 1, fold_sfs))
      }

      par_mat <- do.call(rbind, par_list)
      data.frame(cbind(par_mat, sfs_mat))
    }

    total.sims <- 0
    for(k in 1:nsim.blocks) {
      start.time <- Sys.time()
      simulations <- sim.sfs.func()

      cat("Writing simulations to file", sep = "\n")
      write.table(simulations, file = paste0("SIM_SFS_", output.name, ".txt"),
                  quote = FALSE, row.names = FALSE, col.names = FALSE,
                  append = TRUE, sep = "\t")

      end.time <- Sys.time()
      total.sims <- total.sims + block.size
      cycle.time <- (as.numeric(end.time) - as.numeric(start.time)) / 60 / 60
      total.time <- cycle.time * nsim.blocks
      passed.time <- cycle.time * k
      remaining.time <- round(total.time - passed.time, 3)
      cat(paste("PipeMaster:: ", total.sims, " (~", round(block.size / cycle.time),
                " sims/h) | ~", remaining.time, " hours remaining", sep = ""), "\n")
    }
    f <- ".1locfile.txt"
    if(file.exists(f)) file.remove(f)
    print("Done!")
  }
}


# Internal helper: fold an SFS vector
# sfs has n = nsam-1 entries (frequency classes 1 to nsam-1, monomorphic excluded)
# Pairs frequency k with frequency nsam-k (i.e., index i with index n-i+1)
# When n is odd (nsam even), the middle entry is self-paired
fold_sfs <- function(sfs) {
  n <- length(sfs)
  half <- floor(n / 2)
  folded <- numeric(half)
  for(i in 1:half) {
    folded[i] <- sfs[i] + sfs[n - i + 1]
  }
  if(n %% 2 == 1) {
    folded <- c(folded, sfs[half + 1])
  }
  folded
}

# Internal helper: compute joint SFS from a seg_sites matrix for multi-pop models
# Kept for obs.sfs() which still uses R-based computation
# seg_sites: nsam x n_snps matrix (0/1) with rows ordered by population
# pop_sizes: integer vector of per-population sample sizes
# Returns: array of dimensions (n1+1) x (n2+1) x ... with SNP counts per joint frequency bin
compute_joint_sfs <- function(seg_sites, pop_sizes) {
  npop <- length(pop_sizes)
  dims <- pop_sizes + 1L

  if(ncol(seg_sites) == 0) return(array(0L, dim = dims))

  cum_sizes <- cumsum(c(0L, pop_sizes))

  # Count derived alleles per population for each SNP
  pop_counts <- matrix(0L, nrow = ncol(seg_sites), ncol = npop)
  for(p in 1:npop) {
    rows <- (cum_sizes[p] + 1):cum_sizes[p + 1]
    pop_counts[, p] <- colSums(seg_sites[rows, , drop = FALSE])
  }

  # Build joint SFS using table with proper factor levels
  args <- lapply(1:npop, function(p) factor(pop_counts[, p], levels = 0:pop_sizes[p]))
  sfs_table <- do.call(table, args)

  return(array(as.integer(sfs_table), dim = dims))
}
