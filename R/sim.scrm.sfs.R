#' Simulate Site Frequency Spectra using scrm
#' @description This function simulates the Site Frequency Spectrum (SFS) using the scrm coalescent simulator.
#'              It outputs the SFS (unfolded or folded) averaged across loci for each simulation replicate,
#'              suitable for inference with fastsimcoal2, dadi, moments, etc.
#'              For multi-population models, scrm natively returns the joint SFS as a flattened vector.
#' @param model A model object built by the main.menu function.
#' @param use.alpha Logical. If TRUE the most recent population size change will be exponential. If FALSE sudden demographic changes. Default is FALSE.
#' @param nsim.blocks Number of blocks to simulate. The total number of simulations is: nsim.blocks x block.size (x ncores when ncores > 1).
#' @param block.size Simulations are performed in blocks. This argument defines the size of the block in number of simulations, i.e. how many simulations to run per block.
#'                   A block of 1000 will work for most cases. Increase the total number of simulations with nsim.blocks argument.
#' @param path Path to write the output. By default outputs will be saved in the working directory.
#' @param output.name String. The prefix of the output names. Default is "model".
#' @param append.sims Logical. If TRUE simulations will be appended in the last output. Default is FALSE.
#' @param folded Logical. If TRUE the SFS will be folded. Default is FALSE.
#' @param ncores Number of cores for parallel execution. When ncores > 1, separate R worker processes are spawned. Default is 1.
#' @return Writes simulations (parameters + SFS) to the path directory.
#' @author Marcelo Gehara
#' @export
sim.scrm.sfs <- function(model, use.alpha=FALSE, nsim.blocks=5, block.size=1000,
                          path=getwd(), output.name="model", append.sims=FALSE,
                          folded=FALSE, ncores=1) {

  WD <- getwd()

  if(class(model) != "Model") {
    stop("First argument should be an object of class Model generated by the main.menu() function.")
  }

  # Validate uniform per-population sample sizes across all loci
  npop <- as.numeric(model$I[1, 3])
  pop_cols <- 4:(3 + npop)
  pop_sizes <- matrix(as.numeric(model$I[, pop_cols]), ncol = npop)
  if(nrow(unique(pop_sizes)) > 1) {
    stop("All loci must have uniform per-population sample sizes for SFS simulation.\n",
         "  Use optimize.sfs.model() to downsample your model to uniform sample sizes first.")
  }

  setwd(path)
  on.exit(setwd(WD))

  ############### Header: discover SFS dimensions and write column names
  if(append.sims == FALSE) {
    com <- PipeMaster:::ms.commander2(model, use.alpha = use.alpha)

    # run one scrm call on first locus to discover SFS dimensions
    nsam <- sum(as.numeric(model$I[1, 4:ncol(model$I)]))
    test.result <- scrm::scrm(paste(nsam, 1, com[[1]], "-oSFS"))
    sfs.test <- as.numeric(test.result$sfs)

    # parameter names (drop scalar column)
    par.names <- com[[nrow(model$loci) + 1]][1, ]
    par.names <- par.names[-length(par.names)]

    # SFS column names
    if(folded) {
      folded.sfs <- fold_sfs(sfs.test)
      sfs.names <- paste0("sfs_fold_", seq(0, length(folded.sfs) - 1))
    } else {
      sfs.names <- paste0("sfs_", seq(0, length(sfs.test) - 1))
    }

    nam <- c(par.names, sfs.names)
    write.table(t(nam), file = paste0("SIMS_", output.name, ".txt"),
                quote = FALSE, row.names = FALSE, col.names = FALSE,
                append = FALSE, sep = "\t")
  }

  ############### Multi-core path
  if(ncores > 1) {
    abs.path <- normalizePath(getwd())
    save(model, nsim.blocks, block.size, use.alpha, output.name, folded,
         file = file.path(abs.path, ".PM_worker_params.RData"))

    worker_script <- paste(
      'args <- commandArgs(TRUE)',
      'worker_id <- as.integer(args[1])',
      'suppressMessages(library(PipeMaster))',
      sprintf('base_path <- "%s"', abs.path),
      'load(file.path(base_path, ".PM_worker_params.RData"))',
      'worker_dir <- file.path(base_path, paste0(".worker_", worker_id))',
      'dir.create(worker_dir, showWarnings=FALSE)',
      'sim.scrm.sfs(model=model, nsim.blocks=nsim.blocks, block.size=block.size,',
      '             path=worker_dir, use.alpha=use.alpha, folded=folded,',
      '             append.sims=TRUE,',
      '             output.name=output.name, ncores=1)',
      'write("done", file.path(base_path, paste0(".worker_", worker_id, ".done")))',
      'quit(save="no")',
      sep = "\n")
    writeLines(worker_script, file.path(abs.path, ".PM_worker.R"))

    start.time <- Sys.time()
    for(w in 1:ncores) {
      system(paste("Rscript", file.path(abs.path, ".PM_worker.R"), w,
                   ">", file.path(abs.path, paste0(".worker_", w, ".log")), "2>&1"),
             wait = FALSE)
    }
    cat(paste("PipeMaster:: Launched", ncores, "worker processes"), "\n")

    total_expected <- nsim.blocks * block.size * ncores
    while(TRUE) {
      Sys.sleep(5)
      done_count <- sum(file.exists(file.path(abs.path, paste0(".worker_", 1:ncores, ".done"))))

      total_sims <- 0
      for(w in 1:ncores) {
        wf <- file.path(abs.path, paste0(".worker_", w), paste0("SIMS_", output.name, ".txt"))
        if(file.exists(wf)) {
          n <- length(readLines(wf))
          if(n > 0) total_sims <- total_sims + n
        }
      }

      elapsed_h <- as.numeric(difftime(Sys.time(), start.time, units = "hours"))
      if(total_sims > 0 && elapsed_h > 0) {
        rate <- total_sims / elapsed_h
        remaining <- round(max(0, (total_expected - total_sims) / rate), 3)
        cat(paste0("PipeMaster:: ", total_sims, " of ", total_expected,
                   " (~", round(rate), " sims/h) | ~", remaining,
                   " hours remaining | ", done_count, "/", ncores, " workers done"), "\n")
      }
      if(done_count >= ncores) break
    }

    cat("Compiling results from workers", sep = "\n")
    outfile <- file.path(abs.path, paste0("SIMS_", output.name, ".txt"))
    for(w in 1:ncores) {
      wf <- file.path(abs.path, paste0(".worker_", w), paste0("SIMS_", output.name, ".txt"))
      if(file.exists(wf)) {
        worker_data <- readLines(wf)
        if(length(worker_data) > 0) {
          cat(paste(worker_data, collapse = "\n"), "\n", file = outfile, append = TRUE, sep = "")
        }
      }
      unlink(file.path(abs.path, paste0(".worker_", w)), recursive = TRUE)
      f <- file.path(abs.path, paste0(".worker_", w, ".done"))
      if(file.exists(f)) file.remove(f)
    }
    file.remove(file.path(abs.path, ".PM_worker_params.RData"))
    file.remove(file.path(abs.path, ".PM_worker.R"))
    for(w in 1:ncores) {
      f <- file.path(abs.path, paste0(".worker_", w, ".log"))
      if(file.exists(f)) file.remove(f)
    }

    end.time <- Sys.time()
    elapsed_h <- as.numeric(difftime(end.time, start.time, units = "hours"))
    cat(paste0("PipeMaster:: Done! ", total_expected, " simulations in ",
               round(elapsed_h, 3), " hours (~", round(total_expected / elapsed_h), " sims/h)"), "\n")

  } else {
    ############### Single-core path
    sim.sfs.func <- function() {
      results <- NULL
      for(i in 1:block.size) {
        com <- PipeMaster:::ms.commander2(model, use.alpha = use.alpha)

        # collect SFS across loci
        sfs.list <- list()
        for(u in 1:nrow(model$loci)) {
          nsam <- sum(as.numeric(model$I[u, 4:ncol(model$I)]))
          scrm.out <- scrm::scrm(paste(nsam, 1, com[[u]], "-oSFS"))
          sfs.list[[u]] <- as.numeric(scrm.out$sfs)
        }

        # average SFS across loci
        sfs.mat <- do.call("rbind", sfs.list)
        sfs.mean <- colMeans(sfs.mat, na.rm = TRUE)

        # fold if requested
        if(folded) {
          sfs.mean <- fold_sfs(sfs.mean)
        }

        # extract parameters (drop scalar column)
        par <- com[[nrow(model$loci) + 1]][2, ]
        par <- par[-length(par)]

        results <- rbind(results, c(par, sfs.mean))
      }
      data.frame(results)
    }

    total.sims <- 0
    for(k in 1:nsim.blocks) {
      start.time <- Sys.time()
      simulations <- sim.sfs.func()

      cat("Writing simulations to file", sep = "\n")
      write.table(simulations, file = paste0("SIMS_", output.name, ".txt"),
                  quote = FALSE, row.names = FALSE, col.names = FALSE,
                  append = TRUE, sep = "\t")

      end.time <- Sys.time()
      total.sims <- total.sims + block.size
      cycle.time <- (as.numeric(end.time) - as.numeric(start.time)) / 60 / 60
      total.time <- cycle.time * nsim.blocks
      passed.time <- cycle.time * k
      remaining.time <- round(total.time - passed.time, 3)
      cat(paste("PipeMaster:: ", total.sims, " (~", round(block.size / cycle.time),
                " sims/h) | ~", remaining.time, " hours remaining", sep = ""), "\n")
    }
    print("Done!")
  }
}


# Internal helper: fold an SFS vector
# sfs has n = nsam-1 entries (frequency classes 1 to nsam-1, monomorphic excluded)
# Pairs frequency k with frequency nsam-k (i.e., index i with index n-i+1)
# When n is odd (nsam even), the middle entry is self-paired
fold_sfs <- function(sfs) {
  n <- length(sfs)
  half <- floor(n / 2)
  folded <- numeric(half)
  for(i in 1:half) {
    folded[i] <- sfs[i] + sfs[n - i + 1]
  }
  if(n %% 2 == 1) {
    folded <- c(folded, sfs[half + 1])
  }
  folded
}
